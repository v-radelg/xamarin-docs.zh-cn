---
title: 了解 SiriKit 概念
description: 本文档介绍在 Xamarin iOS 应用程序中使用 SiriKit 时所需的重要概念。 例如, 它讨论了意向和意向 UI 扩展、SiriKit 权限、设计好的体验等。
ms.prod: xamarin
ms.assetid: 99EC5C1E-484F-4371-8555-58C9F60DE37F
ms.technology: xamarin-ios
author: lobrien
ms.author: laobri
ms.date: 05/02/2017
ms.openlocfilehash: b9e8ad848204f7db785327093cd4b7ed9aa6de81
ms.sourcegitcommit: 3ea9ee034af9790d2b0dc0893435e997bd06e587
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 07/30/2019
ms.locfileid: "68654068"
---
# <a name="understanding-sirikit-concepts"></a>了解 SiriKit 概念

_本文介绍了在 Xamarin iOS 应用程序中使用 SiriKit 时所需的重要概念。_


SiriKit 的新功能允许 Xamarin iOS 应用提供用户可使用 Siri 和 iOS 设备上的地图应用程序访问的服务。 此功能在一个或多个使用新的**意图**和**意向 UI**框架的应用扩展中提供。

SiriKit 允许 iOS 应用提供用户可使用 Siri 的用户访问的服务, 以及使用应用扩展**和新的**方法和**意向 UI**框架在 iOS 设备上映射应用的服务。

Siri 适用于**域**的概念、相关任务的一组已知操作。 应用程序与 Siri 之间的每个交互都必须属于其已知的一个服务域, 如下所示:

- 音频或视频呼叫。
- 预订一本。
- 管理 workouts。
- 彩信.
- 搜索照片。
- 发送或接收付款。

当用户发出涉及某个应用扩展服务的 Siri 请求时, SiriKit 将向该扩展发送**意向**对象, 该对象描述用户的请求以及所有支持数据。 然后, 应用扩展会针对给定**意向**生成相应的**响应**对象, 并详细说明扩展如何处理请求。

## <a name="the-intents-and-intents-ui-extensions"></a>意向和意向 UI 扩展

Siri 和 Maps 应用均通过两种不同类型的应用扩展与应用的服务进行交互:

- **意向扩展**-向应用的内容提供 Siri 和 Maps, 并执行所需的任务以满足任何支持的意图。
- **意向 UI 扩展**-提供一个自定义 ui, 该 ui 将在 Siri 或 Maps 内显示应用内容。

应用程序必须提供一种支持 SiriKit 的意图扩展, 并负责提供 Siri 和 Maps 可提供给用户的信息以及处理意向。

创建意向 UI 扩展是可选的, 因为 Siri 通常处理所有用户交互, 并且具有标准的内置 UI, 用于在每个受支持的域中呈现信息。 通过提供意向 UI 扩展, 应用可使用**意向 ui**框架提供丰富的自定义用户界面, 其中包含应用的品牌和其他信息。

## <a name="siri-and-the-maps-app-role"></a>Siri 和 Maps 应用角色

用户的口头请求是由 Siri 处理的语言和以语义方式分析的, 这会将这些请求变成目的扩展可以处理的可操作意向。

Maps 使用应用的意图扩展在映射接口中显示信息, 以响应用户的操作。 例如请求附近餐馆或获取应用的餐馆评论。

Siri 和 Maps 都管理用户的所有交互, 并使用标准系统界面显示结果。 应用扩展角色主要用于提供显示的数据。 应用可以选择提供一个意向 UI 扩展, 并提供自定义 UI 以增强默认系统界面。

## <a name="interacting-with-siri-via-sirikit"></a>通过 SiriKit 与 Siri 交互

本部分概述了 SiriKit 如何允许用户使用 Siri 与应用进行交互。 出于本示例的目的, 我们将使用虚设的 MonkeyChat 应用:

[![](understanding-sirikit-images/monkeychat01.png "MonkeyChat 图标")](understanding-sirikit-images/monkeychat01.png#lightbox)

MonkeyChat 保留自己的用户朋友的联系人手册, 每个与屏幕名称关联 (例如 Bobo), 并允许用户通过屏幕名称向每个朋友发送文本聊天。

用户可以通过多种方式启动与应用程序的交互, 因为不同的人员可能会在许多不同的窗体中发出同一请求。

例如, 如果用户想要将消息发送到其朋友 Bobo, 则他们可能与 Siri 进行了以下对话:

_用户嗨, Siri, 发送 MonkeyChat 消息。_<br />
_Siri谁？_<br />
_用户Bobo._<br />
_Siri要 Bobo 什么？_<br />
_用户请发送更多 Bananas。_<br />

其他人可能会对其他会话发出同一请求:

_用户将消息发送到 MonkeyChat 上的 Bobo。_<br />
_Siri要 Bobo 什么？_<br />
_用户请发送更多 bananas。_<br />

另外, 另一个用户可能会发出更短的请求:

_用户MonkeyChat Bobo 请发送更多 bananas。_<br />
_Siri好的, 发送消息请将更多 bananas 发送到 Monkeychat 上的 Bobo。_<br />

甚至使用其他语言生成相同的请求:

_用户MonkeyChat Bobo s'il vous plaît envoyer plus de bananes。_<br />
_SiriOui、envoi message s'il vous plaît envoyer plus de bananes à Bobo .sur Monkeychat。_<br />

但另一位用户在其会话中可能非常详细:

_用户您好, Siri, 您可以这样做, 然后启动 MonkeyChat 应用程序来发送文本, 同时发送更多 bananas。_<br />
_Siri谁？_<br />
_用户我的最佳 pal Bobo。_<br />

此外, Siri 可以通过多种方式来响应请求, 一些方法基于发出请求的方式:

- **通过按住 Home 按钮**, Siri 将提供更多的视觉反馈, 提供有限的口头反馈。
- **"你好 Siri"** -Siri 将更具口头, 并提供更少的视觉对象响应。

Siri 还进行了优化, 以满足用户的辅助功能需求, 并将根据这些需要进行交互和响应。

无论请求的建立方式或 Siri 响应请求的方式如何, Siri 都可以处理与用户的会话, 应用 (通过其扩展) 可提供功能。

当用户进行 Siri 的口头请求时, Siri 将遵循以下步骤:

[![](understanding-sirikit-images/monkeychat02.png "Siri 将遵循的步骤")](understanding-sirikit-images/monkeychat02.png#lightbox)

1. 首先, Siri 使用用户**语音**的音频, 并将其转换为文本。
2. 接下来, 将文本转换为一个**意向**, 即用户请求的结构化表示形式。
3. 基于意向, Siri 将采取**操作**来执行用户的请求。
4. 最后, Siri 会根据所执行的操作向用户显示**响应**(视觉对象和口头)。

应用可通过以下三种主要方式参与用户与 Siri 的对话:

[![](understanding-sirikit-images/monkeychat03.png "应用可在用户对话中参与 Siri 的三个主要方法")](understanding-sirikit-images/monkeychat03.png#lightbox)

1. **词汇**-这是应用如何告诉 Siri 要与之进行交互所需的字词。
2. **应用逻辑**-根据给定意向, 应用将执行的操作和响应。
3. **用户界面**-这是可选的自定义用户界面, 应用可在其中给出响应。

### <a name="example"></a>示例

考虑到上述信息, 请检查以下会话如何与 MonkeyChat 应用交互:

_用户嗨, Siri, 将消息发送到 MonkeyChat 上的 Bobo。_<br />
_Siri要 Bobo 什么？_<br />
_用户请发送更多 bananas。_<br />

应用在会话中所采用的第一个角色是帮助 Siri 理解用户的语音:

[![](understanding-sirikit-images/monkeychat04.png "帮助 Siri 了解用户语音")](understanding-sirikit-images/monkeychat04.png#lightbox)

Siri 在其数据库中不具有名称 "Bobo", 但应用通过其词汇与 Siri 共享此信息。 此应用还有助于 Siri 识别出 Bobo 是收件人, 因为它将其指定为 "Siri" 作为*联系人*。

Siri 知道发送消息比只是接收方所需的更多, 因此, 它将快速检查应用程序扩展以查看消息是否需要内容。 由于 MonkeyChat, Siri 将响应用户的问题: *"想要如何 Bobo？"*

在上面的示例中, 用户已做出响应, *"请发送更多 bananas"* , Siri 将捆绑到结构化**目的**:

[![](understanding-sirikit-images/monkeychat05.png "Siri 会将用户的响应捆绑到结构化意向")](understanding-sirikit-images/monkeychat05.png#lightbox)

结构化目的将包含以下信息:

- **域名**消息
- **意向:** sendMessage
- **方**Bobo
- **内容：** 请发送更多 bananas

每个域都有一组可在其中执行并基于域和操作的已知*操作*, 发送到应用的意图可能包含零到多个参数。

然后, 将目的发送到应用扩展以进行处理。 由于处理意向, 应用程序将生成一个**IntentResponse** , 该方法将与意向捆绑在一起, 并包括描述应用程序与意向的操作的参数。

每个 IntentResponse 还将包含一个**响应代码**, 该代码会告诉 Siri 应用程序是否能够完成该请求。 某些域还可以发送非常具体的错误响应代码。

最后, IntentResponse 将包括 (例如`NSUserActivity`用于支持移交的)。 如果响应要求用户离开 Siri 环境并输入应用来完成此应用,将使用来启动应用。`NSUserActivity` 

Siri 会自动构建适当`NSUserActivity`的, 以启动应用程序, 并在 Siri 环境中的用户离开的位置进行分拣。 但是, 如果需要, 应用程序可以`NSUserActivity`提供自己的自定义信息。

在应用程序处理意向并返回对 Siri 的响应后, 它会将结果显示给用户 (口头方式传达和视觉上):

[![](understanding-sirikit-images/monkeychat06.png "向用户显示的结果口头方式传达和直观")](understanding-sirikit-images/monkeychat06.png#lightbox)

Siri 为应用提供的每个域都有多个内置响应用户界面。 不过, 由于 MonkeyChat 提供了一个可选的意向 UI 扩展, 因此它用于向上一示例中的用户显示会话的结果。

## <a name="the-intent-lifecycle"></a>意向生命周期

处理意向时, 应用扩展需要执行三个主要任务:

[![](understanding-sirikit-images/monkeychat07.png "意向生命周期")](understanding-sirikit-images/monkeychat07.png#lightbox)

1. 应用必须**解析**事件的每个参数。 因此, 应用程序将多次调用解析 (每个参数一次), 有时在同一参数上多次调用, 直到应用程序和用户同意请求的内容。
2. 应用必须**确认**它可以处理请求的意图, 并告诉 Siri 有关预期结果的信息。
3. 最后, 应用程序必须**处理**意向并执行步骤来实现请求的结果。

### <a name="the-resolve-stage"></a>解析阶段

解析阶段可帮助 Siri 了解用户提供的值, 并确保用户实际使用的值是在应用程序处理意向时所发生的情况。 

此阶段还提供了一种机会, 使应用能够在与用户对话时影响 Siri 的行为。 为此, 应用将提供**解决方法响应**。 Siri 理解的不同类型的数据有很多预定义的响应。

应用最常见的解决方法将是**成功**的, 这意味着应用会将特定数据块从参数 (例如用户屏幕名称) 匹配到它知道的信息。

有时, 应用程序需要确认给定请求是否与它知道的正确信息块匹配。 在这些情况下, 它将发送一个**ConfirmationRequired**响应来向用户询问 "是" 或 "否" 问题, 例如 *"发送消息到 Bobo？* "

在其他情况下, 应用程序将要求用户从一小的选项列表中进行选择。 在这种情况下, 应用将提供**消除歧义**响应, 其中包含两个到十个选项的列表, 用户可从中进行选择, 例如: 

```csharp
Who do you want to message?

* Bobo the Great
* Bobo Jr.
* Little Bobo
```

Siri 将处理进行选择的用户 (无论是口头方式传达还是通过与 Siri UI 交互), 然后将结果发送回应用程序。

在其他情况下, 应用程序可能没有足够的信息来解析参数, 或者可能存在太多的匹配项, 无法使用消除歧义进行解析 (80 例如, 其名称中有 Bobo 的用户)。 在这种情况下, 应用程序将发送一个**NeedsMoreDetails**响应, Siri 会提示用户更具体的信息。

如果用户没有提供处理意向所需的值, 则可以发送**NeedsValue**响应, 使 Siri 提示用户输入值。

如果应用不支持用户为特定参数提供的值, 则它可以发送**UnsupportedWithReason**响应以提供值不受支持的原因。 然后, Siri 将提示用户提供一个全新的值, 并为用户提供所需的原因。

最后, 使用**NotRequired**响应告诉 Siri 应用程序不需要给定参数的值。 如果用户仍然提供一个, 则 Siri 会将其忽略。

### <a name="the-confirm-stage"></a>确认阶段

确认阶段有两个用途:

- 若要告诉 Siri 如何处理意向, 使 Siri 能够告诉用户发生了什么情况。
- 提供机会检查应用可能需要完成用户提出的请求所需的任何状态, 例如, 在银行中有足够的资金来做出请求的付款。

该应用程序将从确认步骤提供**意向响应**, 该响应应使用应用提供的信息来填充, 以便 Siri 可以与用户有效地通信。

根据 "域" 和 "操作类型", Siri 可能会提示用户进行确认, 如发送付款或预订行程之前。

### <a name="the-handle-stage"></a>句柄阶段

句柄阶段是使用意向的最重要部分, 因为它是应用程序通过执行所请求的任务来完成用户请求的点。

正如在确认阶段中所做的那样, 应用程序需要提供尽可能多的有关结果的信息, 因此 Siri 可以将此信息与用户相关联。 有时, 此信息会以可视方式显示或其他 Siri, 而只是将其返回给用户。 

有时, 应用可能需要额外的时间来处理给定的请求, 例如网络呼叫延迟, 或者活动人员需要满足请求 (例如完成和发货订单或推动汽车到用户的位置)。 当 Siri 等待应用返回响应时, 它会向用户显示一个等待 UI, 告诉他们应用正在处理请求。

理想情况下, 应用程序应在两到三秒内最多提供对 Siri 的响应。 如果应用知道给定响应要花费更长时间进行处理, 则需要**将响应代码**发送到 Siri。 然后, Siri 会通知用户应用正在后台处理请求, 并将继续执行此操作, 即使离开 Siri 环境也是如此。

## <a name="adding-sirikit-to-the-app"></a>向应用程序添加 SiriKit

对于 iOS 10 中的 SiriKit, Apple 已创建两个新的扩展点:

- **意向扩展**-为 Siri 提供应用的内容, 并执行所需的任务以满足任何支持的意图。
- **意向 UI 扩展**-提供一个自定义 ui, 该 ui 将在 Siri 内为应用内容显示。 

还提供了一个 API 来向 Siri 提供字词和短语, 以帮助进行识别, 其形式为:

- **应用词汇**-应用的每个用户共用的词和短语。
- **用户词汇**-给定应用用户独有的单词和短语。

## <a name="the-intents-extension"></a>意向扩展

意向扩展负责处理应用和 Siri 之间的主要交互, 如下所示:

[![](understanding-sirikit-images/intents01.png "意向扩展")](understanding-sirikit-images/intents01.png#lightbox)

意向扩展可以支持一个或多个意向, 由开发人员决定如何实现应用程序中的 SiriKit。 开发人员还可以为需要处理的每个意向添加一个单独的意图扩展。  也就是说, Apple 要求开发人员限制意向扩展的数量, 以便 Siri 不会针对应用打开多个进程, 这需要更多的内存和时间来处理。

开发人员还应注意, 在 Siri 处于活动状态时, 目的扩展将在后台运行。 这允许 Siri 与用户主动进行会话, 同时仍与该扩展进行通信, 以便处理有关请求的信息。

## <a name="privacy-and-security-considerations"></a>隐私和安全注意事项

Apple 采取了充分的措施来确保在使用 Siri 时用户的隐私信息是安全的, 因此, 有几个交互需要用户登录到 iOS 设备。 例如, 请求请求或支付款项。

此外, 应用可能想要将特定行为限制为登录到设备的用户。 在这些情况下, 应用程序可以请求**限制锁定**的行为。 这是通过`Info.plist`文件中的设置来完成的。

本地身份验证框架可用于意向扩展, 因此即使设备已解锁, 应用也可以询问用户其他身份验证信息。

最后, Apple Pay 可用于意向扩展, 因此应用可以使用 Apple Pay 完成事务, 内置的 Apple Pay 工作表将显示在 Siri 界面的上方。

此外, Apple 需要确保用户知道何时向第三方应用程序发送信息, 并且在发出请求时, 用户**必须**在应用的捆绑显示名称中指定应用程序的特定名称。

Apple 设计 Siri, 与用户一起执行自然的流畅对话, 因此, 无论在用户的请求中, 无论在哪一种情况下, 都可以在语音的许多部分中使用应用程序的捆绑名称。

用户需要执行的常见操作之一是 "verbify" 应用程序的名称, 换言之, 使用应用名称并将其用作请求中的谓词。 例如, *"MonkeyChat Bobo 这些是出色的 bananas"。*

## <a name="the-intents-ui-extension"></a>意向 UI 扩展

意向 UI 扩展提供了机会, 使应用的 UI 和品牌进入 Siri 体验, 并使用户感觉连接到应用。 通过此扩展, 应用可以将品牌以及视觉对象和其他信息引入到脚本中。

[![](understanding-sirikit-images/intents02.png "示例意向 UI 扩展输出")](understanding-sirikit-images/intents02.png#lightbox)

意向 UI 扩展将始终返回`UIViewController` , 应用可以在视图控制器内添加它喜欢的任何内容, 如显示超出初始响应的附加信息。 使用意向 UI 还可以使用长时间运行的事件的状态来更新用户, 例如, 需要一辆行程共享汽车到达其位置的时间。

意向 UI 扩展将始终与其他 Siri 内容一起显示, 如应用程序图标和 UI 顶部的名称, 或者, 根据目的, 按钮 (如 "发送" 或 "取消") 可能会显示在底部。

在某些情况下, 应用程序可以在默认情况下将 Siri 显示的信息替换为用户, 例如消息传送或映射, 应用程序可以将默认体验替换为应用程序定制的体验。

> [!IMPORTANT]
> 尽管可以向意向 ui 扩展`UIButtons` `UIViewController`添加交互式元素 (例如`UITextFields`或), 但已严格禁止将这些元素作为非交互式的意向 UI, 并且用户将无法与它们进行交互。

应用程序提供意向 UI 扩展是完全可选的, 因为 Siri 包含每个意向类型的一组默认 UI。 此外, 意向 UI 接口仅适用于 Apple 认为对用户有用的某些意向。

## <a name="adding-sirikit-vocabulary"></a>添加 SiriKit 词汇

实现 SiriKit 的最后一个部分是在应用程序中提供所需的词汇。 许多应用程序都有独特的方式向用户描述信息, 以及用户将向应用程序提供信息的独特方式。

因此, Siri 需要应用的帮助来理解应用独有的单词和短语。 其中一些短语会成为应用程序的一部分, 因此, 每个用户都将知道并了解这些短语。 但其他人对应用程序的给定用户是唯一的。

### <a name="app-specific-vocabulary"></a>应用特定词汇

特定于应用程序的词汇定义应用程序的所有用户都知道的特定词和短语, 如车辆类型或健身名称。 由于这些是应用程序的一部分, 因此在应用程序捆绑`AppIntentVocabulary.plist`包中将它们定义为文件。 此外, 应本地化这些字词和短语。

词汇`AppIntentVocabulary.plist`文件有若干部分:

- **示例应用使用**-这些方案为用户可以对应用发出的请求提供了一组常用用例。 例如： *"使用 MonkeyFit 启动健身"。*
- **参数**-这些参数提供了一组特定于应用的非标准参数类型。 例如, MonkeyFit 应用的健身名称。 其中包括:
    - **短语**-允许应用为应用定义独特条款。 例如: MonkeyFit 应用的 "Bananarific" 健身类型。 
    - **发音**-向 Siri 提供发音提示, 作为给定短语的简单语音拼写。 例如, "ba nana ri f"。
    - **示例**-提供在应用程序中使用给定短语的示例。 例如, *"在 MonkeyFit 中启动 Bananarific"* 。

有关详细信息, 请参阅 Apple 的[应用词汇文件格式参考](https://developer.apple.com/library/prerelease/content/documentation/Intents/Conceptual/SiriIntegrationGuide/CustomVocabularyKeys.html#//apple_ref/doc/uid/TP40016875-CH10-SW1)。

### <a name="user-specific-vocabulary"></a>用户特定词汇

用户特定词汇将提供应用的各个用户独有的词或短语。 在运行时, 将从主应用 (而不是应用扩展) 将这些信息提供给用户最重要的使用优先级的一组有序术语, 其中最重要的术语位于列表的开头。

查看上面提供的 MonkeyChat 应用的示例。 MonkeyChat 将保留用户的所有联系人的列表, 该列表将通过用户特定词汇发送到 Siri。 它还会保留用户已消息的10个最新联系人列表, 并为每个用户提供一组喜爱的联系人。 对于本示例, 收藏联系人应位于用户特定词汇的开头, 后跟最近的联系人, 然后是用户的其余联系人。

用户特定词汇支持以下类型的信息:

- 联系人姓名。
- 健身名称。
- 相册名称。
- 照片关键字。

如果应用依赖于 iOS 通讯簿, 应用将不需要执行任何操作, 因为 Siri 已提供此信息。 如果应用程序具有自己的唯一联系人数据库, 则该应用程序只需提供联系人姓名。

在设计词汇时, 只提供用户了解和关注的必需值。 避免提供电话号码或电子邮件地址等信息。

此应用还需要在用户特定词汇发生更改时立即更新 Siri。 用户习惯于请求从 Siri 添加到其 iOS 设备的信息。 例如, 如果用户在应用中添加了一个新的联系人, 则在用户保存该信息后立即将其发送到 Siri。

更重要的是, 应用程序_必须_立即删除 Siri 词汇中的信息, 因为如果用户删除了一条信息, 但 Siri 仍识别出的时间或天, 则该用户可能会感到不安。

> [!IMPORTANT]
> 如果用户选择重置应用或注销, 应用应删除 Siri 中的所有用户特定词汇。

## <a name="sirikit-permissions"></a>SiriKit 权限

最终 SiriKit 的中心围绕权限。 与使用 iOS 的其他功能 (如照片、照相机或联系人) 一样, 用户必须为应用授予显式权限, 才能与 Siri 通信。

应用程序能够提供一个字符串来定义它将提供给 Siri 的信息, 并提供有关用户应授予此访问权限的原因。 

Apple 建议应用在用户第一次打开应用后, 用户首次打开应用时, 应该请求用户使用 Siri 的权限。 这是为了让用户了解 Siri 集成, 并可以在进行第一次请求之前预批准使用。

## <a name="sirikit-and-maps"></a>SiriKit 和 Maps

SiriKit 是 iOS 的有机组成部分, 并使用已添加到 iOS 10 的更大的方法框架。 意向框架旨在与系统的其他部分共享公共和共享操作。

意向框架不仅仅是 Siri 的集成, 还提供了其他功能, 例如, 应用可成为特定联系人的默认电话服务或消息应用的联系人集成。 意向还提供与 CallKit 的深度集成, 为用户提供尽可能最好的 VOIP 体验。

IOS 10 中的 Maps 应用添加了一些功能, 例如, 用户可以直接在地图 UI 内部预订一项功能。 SiriKit 提供了一个带有地图的常见扩展点, 因此可以在 Siri 和 Maps 之间共享 "允许共享" (和其他) 方法。 

这意味着, 如果应用程序采用了 SiriKit 扩展, 它还会免费获取地图集成。 

## <a name="designing-a-great-siri-experience"></a>设计出色的 Siri 体验

在将应用集成到 Siri 时设计极佳的用户体验不同于设计卓越的应用用户界面。 与用户在屏幕上直接交互的正常情况不同, 在使用 Siri 时, 很多时候都根本看不到任何可视界面。 例如, 当用户已启动 *"你好 Siri"* 的对话时。

### <a name="how-siri-helps-the-developer"></a>Siri 如何帮助开发人员

在设计应用程序与 Siri 的交互时, 应用程序将生成*对话界面*, 这意味着上下文派生自 Siri 在应用程序上代表用户的对话。

如果没有视觉引用, 用户必须跟踪其标题中显示的信息。 因此, Siri 提供了实现用户希望完成的任务所需的最少信息。

对话界面是用户和 Siri 在对话过程中的问题和响应的形状。 因此, 请务必考虑 Siri 在设计此界面时如何提出问题和做出响应。

请在下面的示例中, 创建一条消息, Siri 可能会出现 "已*准备好发送它？"* 的问题。 用户可以通过多种不同的方式进行响应, 如 *"发送*"、 *"取消"* , 甚至与此问题完全无关的内容。 不管会话的播放方式如何, Siri 将对应用程序进行处理, 并且仅在可用信息可用时向其发送相关信息。

用户可以通过多种不同的方式启动与 Siri 的对话:

- 通过选取设备, 按 "主页" 按钮。 在这种情况下, Siri 将提供更多视觉对象和不太口头的响应。
- 说 *"你好 Siri"* , 开始免费对话。 在这种情况下, Siri 的视觉对象和语言更少。
- 使用启用 bluetooth 的功能等辅助功能可帮助用户为有特殊需求的用户定制 UI。
- 使用汽车 Play, 用户需要将干扰保持在最小的位置, 使其关注。

### <a name="how-the-developer-helps-siri"></a>开发人员如何帮助 Siri

在将应用程序与 Siri 集成时, 开发人员需要经常测试此集成, 并通过在尽可能多的不同方法中请求相同的信息或任务来确保他们做出许多不同的请求。

由于没有两人认为这种情况, 开发人员非常重要的一点是, 开发人员可尽可能多地获取不同的 beta 测试人员来帮助优化 Siri 集成。 用户可能会要求提供信息或发出请求, 因为开发人员绝不会这样做, 而这种微调可帮助确保最大范围的用户在使用 Siri 的应用程序方面获得良好的体验。

在不同的情况和环境中进行测试。 以所有可能的方式启动与 Siri 的会话, 以确保这些会话保持流畅和自然。 在用户可能使用应用程序的位置 (例如在拥挤的健身房中) 进行测试。

确保该应用程序提供了 Siri 为用户正确表示请求和结果所需的所有信息。 在使用 Siri 时尤其如此。

### <a name="siri-design-guidelines"></a>Siri 设计指南

请始终记住, Siri 是代表该应用与用户进行对话。 开发人员希望不确定此对话尽可能流畅和自然。

与任何重要的对话一样, 开发人员需要确保以下各项:

- 应用已准备好进行会话。
- 应用程序会确切地侦听用户尝试完成的操作。
- 应用程序在适当的时间请求适当的问题。
- 应用程序会用用户正在寻找的信息来响应请求。

#### <a name="preparing-for-the-conversation"></a>准备对话

首先要记住的是, 应用的用户与开发人员并不完全相同。 它们可能来自不同背景、说话不同语言或在使用应用时有特殊需求。

此外, 由于开发人员设计并构建了应用程序, 因此他们对应用及其内部工作原理和函数 (一般用户将不会有) 有深入的了解。 因此, 开发人员可能会要求 Siri 与普通用户的请求不同。

这就是为什么要使多个用户能够通过 Siri 与应用程序进行交互至关重要的原因。 用户可能会通过 Siri 为应用程序提供请求, 因为开发人员从未想象过或开发人员未考虑的方式。

#### <a name="ensure-the-app-is-a-good-listener"></a>确保该应用程序是良好的侦听器

开发人员需要确保该应用程序是一个不错的侦听器, 并获得满足用户期望的会话细节。 但也可能是他们未提供应用程序实现请求任务所需的所有信息。

应用可通过多种方式来处理这种情况:

- **为缺失值选择一个良好的默认值**-例如, 如果用户未指定要从其选取的位置, 则该用户的当前位置可能会默认为 "用户当前位置"。
- 使用应用已在用户上收集的特定信息**进行一项教育, 使**应用程序能够对缺少的信息进行推测和教育, 如使用用户的联系信息填写缺少的移动电话号码。 不过, 应注意避免意外的意外, 如选取最昂贵的选项, 等等。
- **提示详细信息**-应用可以让 Siri 提示用户输入缺失值。 但是, 此处的关键是使会话保持简单和点。 如果用户必须回答几个问题来完成其请求, 用户将很快变成不合规。
- **适当地处理误报**-用户可以提供一个值, 该值表示应用不需要, 或者无法在给定的上下文中处理。 请确保应用将这种情况与用户相关联, 从而使其更清晰且更易于更正。

当应用程序显示有问题的单个值时, 处理此问题的首选方法是让 Siri 请求用户进行确认。 例如, *"您的意思是说 Bobo 好了吗？"* , 他们可以使用简单的 "是" 或 "否" 答案来回复。

如果出现这样一种情况: 对于单个值, 可能有几个可能的选择是正确的, 则消除歧义是首选处理方法。 在这种情况下, Siri 可以提示用户提供最多十个可能的选项来进行选择。 例如：

```csharp
Who do you want to send the message to?

* Bobo the Great!
* Bobo Jr.
* Little Bobo
```

如果仍有问题, 请让 Siri 提示用户为给定值提供全新的、更具体的答案。

#### <a name="request-final-confirmation"></a>请求最终确认

在应用实际执行任务以满足用户的请求之前, Siri 将检查应用扩展以确保一切已就绪。 例如, 用户在帐户中是否有足够的资金来做出请求的支付？

此外, 应用程序还需要确保它能够提供 Siri 的所有信息, 以便将其提供给用户, 并确认要执行的任务是否符合预期。

一旦用户确认了该请求并且应用程序执行了该操作, 则应用程序需要再次确保已将所有结果提供给 Siri, 以便将其与用户相关联。

#### <a name="responding-to-the-request"></a>响应请求

Siri 提供了多个内置用户界面, 适用于每个域以及它知道的操作。 但是, 在适当的情况下, 应用程序可以提供自定义意向 UI 扩展, 通过提供与请求中存在的应用程序的品牌和 UI 或更多信息来增强用户体验。

也就是说, 设计 Siri 的自定义接口时应使用挡板。 通常情况下, 用户需要尽快完成特定的任务, 而不想使用不必要的信息重载。

还应注意确保自定义 UI 在用户可能具有或使用设备的所有不同 iOS 设备和方向上正确显示和响应。

如果需要, 请使用 SiriKit API 隐藏默认 Siri UI 中已存在的任何冗余信息。 但请确保该应用仍向 Siri 提供该信息, 这样它就可以在无人参与的情况下将其口头方式传达。

在某些情况下, Siri 将启动应用以满足用户的请求, 例如, 提供用户请求的照片。 在这些情况下, 不要让用户感到惊讶。 显示所需的信息, 而无需执行中间步骤或进一步交互。 从不显示信息或执行用户不需要的任务。

### <a name="polishing-the-design"></a>改进设计

Apple 建议通过几个步骤来修饰对话接口的设计。 首先, 为 Siri 提供清晰、简洁的词汇和用例示例。

用户发现应用的一种方法是通过与 Siri 发起对话, 并询问 *"你可以做什么？"* Siri 将显示它可以执行的几个不同的操作, 其中包括开发人员的应用程序, 以及通过其`plist`文件提供的示例英雄用例。

如何编写好的示例用例:

- 确保示例包含应用名称。
- 保持示例的简短和点。
- 为应用支持的每个意向提供多个示例。
- 根据应用程序的最常见用例, 为二者中的方法和示例设置优先级。
- 确保应用提供本地化的示例。
- 确保给定的每个示例在应用中按预期方式工作。
- 请避免在示例中寻址 Siri, 因此不要包含类似于 *"你好 Siri ..."* 的文本
- 避免任何不必要的 pleasantries, 例如 *"请"* 或 *"谢谢"* 。

请花适当的时间浏览和试验应用如何才能代表用户 Siri 与用户进行会话。 请确保在整个过程中与典型用户交谈, 因为其与应用程序的交互和应用程序的预期会随时间而改变。

务必记住在不同情况下测试应用程序, 以及使用 Siri 调用会话的所有不同方法。 在真实世界位置进行测试, 用户可能正在使用该应用, 远离办公室和办公桌。

努力让与 Siri 的对话 (代表应用程序) 非常流畅、自然和 "感受"。 

## <a name="summary"></a>总结

本文介绍了使用 SiriKit 所需的关键概念, 并将其显示为与 Xamarin iOS 应用程序交互, 以提供用户可使用 Siri 和 iOS 设备上的地图应用程序访问的服务。




## <a name="related-links"></a>相关链接

- [ElizaChat 示例](https://docs.microsoft.com/samples/xamarin/ios-samples/ios10-elizachat)
- [SiriKit 编程指南](https://developer.apple.com/library/prerelease/content/documentation/Intents/Conceptual/SiriIntegrationGuide/index.html)
- [意向框架参考](https://developer.apple.com/reference/intents)
- [意向 UI 框架引用](https://developer.apple.com/reference/intentsui)

---
title: 容器化微服务
description: 本章介绍了如何使用微服务和容器来构建灵活、可缩放且可靠的新式云应用程序。
ms.prod: xamarin
ms.assetid: 5872ad92-04e0-4f1a-9691-79d5602f5683
ms.technology: xamarin-forms
author: davidbritch
ms.author: dabritch
ms.date: 08/07/2017
ms.openlocfilehash: dc71da512519cdd7fcc56df1ff987ffbc1354663
ms.sourcegitcommit: 57f815bf0024b1afe9754c0e28054fc0a53ce302
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/06/2019
ms.locfileid: "70760396"
---
# <a name="containerized-microservices"></a>容器化微服务

开发客户端-服务器应用程序已导致重点介绍如何构建使用每个层中特定技术的分层应用程序。 此类应用程序通常称为*单片*应用程序，并打包到针对峰值负载进行预缩放的硬件上。 此开发方法的主要缺点是每个层内组件之间的紧密耦合，无法轻松缩放单个组件以及测试成本。 简单的更新可能会对层的其余部分产生不可预见的影响，因此对应用程序组件的更改需要重新测试和重新部署其整个层。

尤其是在云的时代，不能轻松缩放单个组件。 单一应用程序包含特定于域的功能，通常由功能层划分，如前端、业务逻辑和数据存储。 通过将整个应用程序克隆到多台计算机来扩展单一应用程序，如图8-1 所示。

![](containerized-microservices-images/monolithicapp.png "单一应用程序缩放方法")

**图 8-1**：单一应用程序缩放方法

## <a name="microservices"></a>微服务

微服务为应用程序开发和部署提供了不同的方法，这种方法适用于现代云应用程序的灵活性、规模和可靠性要求。 微服务应用程序分解为独立的组件，这些组件协同工作以提供应用程序的总体功能。 术语 "微服务" 强调应用程序应该由小型服务组成，以反映独立的问题，以便每个微服务实现一个函数。 此外，每个微服务都有明确定义的协定，使其他微服务可以与它进行通信和共享数据。 典型的微服务示例包括购物车、库存处理、购买子系统和付款处理。

与横向扩展的巨大单一应用程序相比，微服务可以独立扩展。 这意味着，可以缩放特定功能区域，这需要更多的处理能力或网络带宽来支持需求，而不是不必要地扩展应用程序的其他区域。 图8-2 说明了这种方法，在此方法中，微服务是单独部署和缩放的，它跨计算机创建服务的实例。

![](containerized-microservices-images/microservicesapp.png "微服务应用程序缩放方法")

**图 8-2**：微服务应用程序缩放方法

微服务扩展可以近乎瞬间完成，使应用程序能够适应不断变化的负载。 例如，应用程序的面向 web 的功能中的单个微服务可能是应用程序中的唯一微服务，需要横向扩展以处理额外的传入流量。

应用程序可伸缩性的典型模型是具有负载平衡的无状态层，其中包含共享的外部数据存储，用于存储持久性数据。 有状态微服务管理自己的持久数据，通常将其存储在本地服务器上，以避免网络访问的开销和跨服务操作的复杂性。 这可以实现最快的数据处理，并可以消除缓存系统的需求。 此外，可缩放的有状态微服务通常会在其实例中对数据进行分区，以管理一个服务器可支持的数据大小和传输吞吐量。

微服务还支持独立更新。 微服务之间的这种松散耦合可提供快速可靠的应用程序发展。 其独立的分布式性质支持滚动更新，其中只有一个微服务的实例子集会在任意给定时间更新。 因此，如果检测到问题，则在使用错误的代码或配置对所有实例进行更新之前，可能会回滚有问题的更新。 同样，微服务通常使用架构版本控制，以便在应用更新时客户端看到一致的版本，而不考虑要与哪个微服务实例通信。

因此，微服务应用程序对单一应用程序具有许多好处：

- 每个微服务都相对较小，易于管理和发展。
- 每个微服务都可以独立于其他服务来开发和部署。
- 每个微服务都可以独立扩展。 例如，目录服务或购物篮服务可能需要比订购服务多出。 因此，在扩展时，生成的基础结构将更有效地使用资源。
- 每个微服务都隔离任何问题。 例如，如果某个服务出现问题，它只会影响该服务。 其他服务可以继续处理请求。
- 每个微服务都可以使用最新技术。 由于微服务是自治的并且并行运行，因此可以使用最新的技术和框架，而不是强制使用可由单一应用程序使用的较旧框架。

不过，基于微服务的解决方案也有潜在的缺点：

- 选择如何将应用程序分区到微服务可能会很困难，因为每个微服务都必须是完全自治、端到端的，其中包括数据源的责任。
- 开发人员必须实现服务间通信，这会增加应用程序的复杂性和延迟。
- 通常无法在多个微服务之间进行原子事务。 因此，业务要求必须采用微服务之间的最终一致性。
- 在生产环境中，部署和管理很多独立服务的系统会有一个操作复杂性。
- 直接的客户端到微服务通信可能会导致难以重构微服务的协定。 例如，随着时间的推移，系统如何分区到服务中可能需要更改。 单个服务可以拆分为两个或更多服务，两个服务可能合并。 当客户端直接与微服务通信时，此重构工作可能会中断与客户端应用的兼容性。

## <a name="containerization"></a>容器化

容器化是一种软件开发方法，其中，应用程序及其版本控制的依赖项，以及作为部署清单文件提取的环境配置将作为容器映像打包在一起，作为一个单元进行测试，然后部署到主机操作系统。

容器是一个独立的、资源控制的、可移植的操作环境，在此环境中，应用程序可以运行，而无需接触其他容器或主机的资源。 因此，容器的外观和作用类似于新安装的物理计算机或虚拟机。

容器和虚拟机之间存在很多相似之处，如图8-3 所示。

![](containerized-microservices-images/containersvsvirtualmachines.png "微服务应用程序缩放方法")

**图 8-3**：虚拟机和容器的比较

容器运行操作系统，具有文件系统，并且可以通过网络访问，就像它是物理或虚拟机。 不过，容器使用的技术和概念与虚拟机有很大的不同。 虚拟机包括应用程序、所需的依赖项和完全来宾操作系统。 容器包括应用程序及其依赖项，但与其他容器共享操作系统，这些容器作为主机操作系统上的隔离进程运行（除了在每个容器的特殊虚拟机内运行的 Hyper-v 容器之外）。 因此，容器共享资源，通常比虚拟机需要的资源少。

面向容器的开发和部署方法的优点是，它消除了不一致的环境设置和这些环境中出现的问题所带来的大部分问题。 此外，容器可根据需要实例化新容器，以允许快速应用程序扩展功能。

创建和使用容器的关键概念包括：

- 容器主机：配置为承载容器的物理或虚拟机。 容器主机将运行一个或多个容器。
- 容器映像：映像由分层的文件系统的联合组成，它们彼此堆积，是容器的基础。 映像没有状态，并且在部署到不同环境时它永远不会更改。
- 容器容器是映像的运行时实例。
- 容器操作系统映像：从映像部署容器。 容器操作系统映像是组成容器的许多映像层中的第一层。 容器操作系统是不可变的，不能修改。
- 容器存储库：每次创建容器映像时，映像及其依赖项都存储在本地存储库中。 这些映像可以在容器主机上重复使用多次。 容器映像还可以存储在公共或私有注册表（如[Docker Hub](https://hub.docker.com/)）中，以便可以在不同的容器主机上使用它们。

在实现基于微服务的应用程序时，企业越来越采用容器，而 Docker 已经成为了大多数软件平台和云供应商采用的标准容器实现。

EShopOnContainers 参考应用程序使用 Docker 来托管四个容器化后端微服务，如图8-4 所示。

![](containerized-microservices-images/microservicesarchitecture.png "eShopOnContainers 引用应用程序后端微服务")

**图 8-4**： eShopOnContainers 引用应用程序后端微服务

引用应用程序中后端服务的体系结构以协作微服务和容器的形式分解为多个自治子系统。 每个微服务都提供单一功能区域：标识服务、目录服务、订购服务和购物篮服务。

每个微服务都有自己的数据库，使其与其他微服务完全分离。 必要时，可以使用应用程序级事件实现不同微服务数据库之间的一致性。 有关详细信息，请参阅[微服务之间的通信](#communication_between_microservices)。

有关引用应用程序的详细信息，请[参阅 .net 微服务：适用于容器化 .NET 应用程序的体系结构](https://aka.ms/microservicesebook)。

<a name="communication_between_client_and_microservices" />

## <a name="communication-between-client-and-microservices"></a>客户端与微服务之间的通信

EShopOnContainers 移动应用与容器化后端微服务通信，并使用*直接的客户端到微服务*通信，如图8-5 所示。

![](containerized-microservices-images/directclienttomicroservicecommunication.png "微服务应用程序缩放方法")

**图 8-5**：客户端到微服务直接通信

通过直接的客户端到微服务通信，移动应用可通过其公共终结点直接请求每个微服务，并为每个微服务提供不同的 TCP 端口。 在生产环境中，终结点通常会映射到微服务的负载均衡器，该负载均衡器将请求分布到可用实例上。

> [!TIP]
> 请考虑使用 API 网关通信。 直接的客户端到微服务通信在构建大型、复杂的基于微服务的应用程序时可能会有缺点，但对于小型应用程序而言，这种情况是不够的。 使用数十个微服务设计大型微服务应用程序时，请考虑使用 API 网关通信。 有关详细信息，请[参阅 .net 微服务：适用于容器化 .NET 应用程序的体系结构](https://aka.ms/microservicesebook)。

<a name="communication_between_microservices" />

## <a name="communication-between-microservices"></a>微服务之间的通信

基于微服务的应用程序是可能在多台计算机上运行的分布式系统。 每个服务实例通常是一个进程。 因此，服务必须使用进程间通信协议（如 HTTP、TCP、高级消息队列协议（AMQP）或二进制协议）进行交互，具体取决于每个服务的性质。

微服务到微服务通信的两种常见方法是：在查询数据时，基于 HTTP 的 REST 通信，以及在多个微服务间通信更新时的轻型异步消息传送。

当跨多个微服务传播更改时，基于事件驱动的异步通信是异步的。 使用此方法时，微服务会在出现一些问题（例如，更新业务实体时）时发布事件。 其他微服务订阅这些事件。 然后，当微服务收到事件时，它将更新其自己的业务实体，这可能会导致更多的事件发布。 此发布-订阅功能通常是通过事件总线实现的。

事件总线允许微服务之间的发布-订阅通信，无需彼此明确地识别组件，如图8-6 所示。

![](containerized-microservices-images/eventbus.png "发布-订阅事件总线")

**图8-6：** 发布-订阅事件总线

从应用程序的角度来看，事件总线只是通过接口公开的发布-订阅通道。 但是，实现事件总线的方式可能会有所不同。 例如，事件总线实现可使用 RabbitMQ、Azure 服务总线或其他服务总线，如 NServiceBus 和 MassTransit。 图8-7 显示了如何在 eShopOnContainers 引用应用程序中使用事件总线。

![](containerized-microservices-images/microservicesarchitecturewitheventbus.png "引用应用程序中异步事件驱动的通信")

**图8-7：** 引用应用程序中异步事件驱动的通信

使用 RabbitMQ 实现的 eShopOnContainers 事件总线提供一对多的异步发布-订阅功能。 这意味着在发布事件之后，可以有多个订阅服务器侦听同一事件。 图8-9 说明了这种关系。

![](containerized-microservices-images/eventdrivencommunication.png "一对多通信")

**图 8-9**：一对多通信

这一一对多通信方法使用事件实现跨多个服务的业务事务，确保服务之间的最终一致性。 最终一致事务由一系列分布式步骤组成。 因此，当用户配置文件微服务收到 UpdateUser 命令时，它会在其数据库中更新用户的详细信息，并将 UserUpdated 事件发布到事件总线。 购物篮微服务和订购微服务都已订阅接收此事件，并在响应中更新其各自数据库的买家信息。

> [!NOTE]
> 使用 RabbitMQ 实现的 eShopOnContainers 事件总线仅用作一种概念证明。 对于生产系统，应考虑备选事件总线实现。

有关事件总线实现的信息，请参阅[.net 微服务：适用于容器化 .NET 应用程序的体系结构](https://aka.ms/microservicesebook)。

## <a name="summary"></a>总结

微服务提供一种应用程序开发和部署的方法，可满足现代云应用程序的敏捷性、规模和可靠性要求。 微服务的主要优点之一是，它们可以独立地横向扩展，这意味着可以为了支持需求而扩展需要更多处理能力或网络带宽的特定功能区域，但不必扩展未出现需求增加的应用程序的所在区域。

容器是一个独立的、资源控制的、可移植的操作环境，在此环境中，应用程序可以运行，而无需接触其他容器或主机的资源。 在实现基于微服务的应用程序时，企业越来越采用容器，而 Docker 已经成为了大多数软件平台和云供应商采用的标准容器实现。

## <a name="related-links"></a>相关链接

- [下载电子书（2Mb）](https://aka.ms/xamarinpatternsebook)
- [eShopOnContainers （GitHub）（示例）](https://github.com/dotnet-architecture/eShopOnContainers)
